/* This file was generated by the Hex-Rays decompiler version 9.1.0.250226.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 (**init_proc())(void);
__int64 sub_401020(); // weak
// void free(void *ptr);
// char *strncpy(char *dest, const char *src, size_t n);
// __int64 __fastcall cJSON_GetObjectItem(_QWORD, _QWORD); weak
// __int64 __fastcall cJSON_Print(_QWORD); weak
// int puts(const char *s);
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// int fclose(FILE *stream);
// size_t strlen(const char *s);
// int printf(const char *format, ...);
// __int64 __fastcall cJSON_Parse(_QWORD); weak
// void *memset(void *s, int c, size_t n);
// __int64 __fastcall cJSON_GetArraySize(_QWORD); weak
// char *strncat(char *dest, const char *src, size_t n);
// void *calloc(size_t nmemb, size_t size);
// int strcmp(const char *s1, const char *s2);
// __int64 ftell(FILE *stream);
// void *memcpy(void *dest, const void *src, size_t n);
// __int64 __fastcall png_image_begin_read_from_file(_QWORD, _QWORD); weak
// __int64 __fastcall cJSON_GetArrayItem(_QWORD, _QWORD); weak
// void *malloc(size_t size);
// int fseek(FILE *stream, __int64 off, int whence);
// double __fastcall cJSON_GetNumberValue(_QWORD); weak
// void *realloc(void *ptr, size_t size);
// __int64 __fastcall png_image_finish_read(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// FILE *fopen(const char *filename, const char *modes);
// __int64 __fastcall cJSON_GetStringValue(_QWORD); weak
// char *strcat(char *dest, const char *src);
// int sprintf(char *s, const char *format, ...);
// void __noreturn exit(int status);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// char *strdup(const char *s);
// char *strstr(const char *haystack, const char *needle);
// __int64 __fastcall png_image_free(_QWORD); weak
void __fastcall __noreturn start(__int64 a1, __int64 a2, void (*a3)(void));
void *sub_401950();
void *sub_4019C0();
__int64 sub_4019F0(); // weak
__int64 __fastcall sub_401A00(__int64 a1, int a2, int a3, int a4, int a5, int a6);
int __fastcall sub_401AE0(int a1);
__int64 __fastcall sub_401B30(__int64 a1, FILE *a2);
__int64 __fastcall sub_401B80(char *s1); // idb
__int64 __fastcall sub_401F40(char *a1, char a2, const char *a3, __int64 a4, const char *a5, __int16 a6, __int16 a7, __int16 a8, __int16 a9, char a10, char a11, char a12);
int __fastcall sub_402100(char a1, unsigned __int8 a2, int a3, unsigned __int8 a4, unsigned __int8 a5, int a6, int a7, __int64 a8, int *a9, const char *a10);
_BYTE *__fastcall sub_402170(unsigned __int8 a1, __int16 a2, __int16 a3, char a4, int a5);
__int64 __fastcall sub_4021E0(__int64 a1, __int64 a2, int a3);
char *__fastcall sub_402290(__int64 a1, int *a2, int a3, int a4, int a5);
char *__fastcall sub_402760(__int64 a1);
__int64 __fastcall sub_402AC0(unsigned __int8 *a1, __int64 a2, _DWORD *a3, int a4, int a5, int a6, int a7);
__int64 __fastcall sub_402E30(FILE *stream); // idb
_WORD *__fastcall sub_402E70(__int64 a1);
void fini(void); // idb
void term_proc();
// int _libc_start_main(int (*main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end);
// __int64 _gmon_start__(void); weak

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN main;
_UNKNOWN init;
__int64 (__fastcall *off_405DE0[2])() = { &sub_4019F0, &sub_4019C0 }; // weak
__int64 (__fastcall *off_405DE8)() = &sub_4019C0; // weak
__int64 (*qword_406010)(void) = NULL; // weak
char *off_406140 = "BLK_PREVI"; // weak
char byte_406148[] = { '\x01' }; // weak
_UNKNOWN unk_4062F0; // weak
char byte_406300; // weak
void *ptr; // idb
__int64 qword_406328; // weak
_UNKNOWN unk_406340; // weak
__int16 word_407740; // weak
char byte_407742; // weak
char byte_407743; // weak
char byte_407744; // weak
char src[255]; // idb
char byte_40785F; // weak


//----- (0000000000401000) ----------------------------------------------------
__int64 (**init_proc())(void)
{
  __int64 (**result)(void); // rax

  result = &_gmon_start__;
  if ( &_gmon_start__ )
    return (__int64 (**)(void))_gmon_start__();
  return result;
}
// 407970: using guessed type __int64 _gmon_start__(void);

//----- (0000000000401020) ----------------------------------------------------
__int64 sub_401020()
{
  return qword_406010();
}
// 401020: using guessed type __int64 sub_401020();
// 406010: using guessed type __int64 (*qword_406010)(void);

//----- (0000000000401240) ----------------------------------------------------
__int64 __fastcall main(int a1, char **a2, char **a3)
{
  FILE *v3; // rbp
  int v4; // eax
  size_t v5; // rbx
  void *v6; // r12
  unsigned int v7; // r14d
  __int64 v8; // rbp
  __int64 ObjectItem; // rax
  const char *StringValue; // rax
  __int64 v11; // r13
  int ArraySize; // ebx
  __int64 v13; // rsi
  __int64 ArrayItem; // rbp
  __int64 v15; // rax
  __int64 v16; // rax
  __int64 v17; // rax
  __int64 v18; // rax
  __int64 v19; // rax
  __int64 v20; // rax
  __int64 v21; // rax
  __int64 v22; // rax
  const char *v23; // r12
  __int64 v24; // rax
  __int64 v25; // rax
  const char *v26; // r15
  __int64 v27; // rax
  __int64 v28; // rax
  char *v29; // rax
  int v30; // ebp
  int v31; // ebx
  int v32; // ebx
  unsigned __int8 *v33; // rax
  int v34; // edx
  int v35; // r13d
  void *v36; // r9
  int v37; // ebx
  __int64 v38; // r15
  int v39; // r12d
  __int64 v40; // rax
  int v41; // eax
  __int64 v42; // r14
  __int64 v43; // rbp
  char *v44; // rdi
  int v45; // r10d
  int *v46; // rcx
  int v47; // eax
  int v48; // esi
  __int64 v49; // rdx
  __int64 result; // rax
  unsigned __int16 v51; // r12
  int v52; // esi
  char *v53; // rbx
  __int64 v54; // r13
  int v55; // r14d
  const char *v56; // r10
  int v57; // esi
  char *v58; // rax
  int v59; // edx
  int v60; // r8d
  int v61; // edi
  int v62; // r9d
  int v63; // ecx
  int v64; // esi
  __int16 v65; // r10
  __int64 v66; // rbx
  char *v67; // r8
  char *v68; // rax
  FILE *v69; // r12
  char *v70; // rdi
  int v71; // [rsp-18h] [rbp-520h]
  double v72; // [rsp+0h] [rbp-508h]
  int v73; // [rsp+0h] [rbp-508h]
  double v74; // [rsp+8h] [rbp-500h]
  double v75; // [rsp+10h] [rbp-4F8h]
  double v76; // [rsp+18h] [rbp-4F0h]
  double v77; // [rsp+20h] [rbp-4E8h]
  double v78; // [rsp+28h] [rbp-4E0h]
  double v79; // [rsp+30h] [rbp-4D8h]
  double v80; // [rsp+38h] [rbp-4D0h]
  double NumberValue; // [rsp+40h] [rbp-4C8h]
  void *v82; // [rsp+48h] [rbp-4C0h]
  char dest[128]; // [rsp+50h] [rbp-4B8h] BYREF
  _DWORD ptr[270]; // [rsp+D0h] [rbp-438h] BYREF

  if ( a1 <= 1 )
  {
    puts("Input file missing");
    return 0;
  }
  else
  {
    v3 = fopen(a2[1], "r");
    v4 = sub_402E30(v3);
    v5 = v4;
    printf("input file size=%d Bytes\n", v4);
    v6 = malloc(v5);
    if ( v5 != fread(v6, 1u, v5, v3) )
    {
      puts("File reading error...");
      exit(0);
    }
    v7 = 0;
    puts("Entire file loaded successfully.");
    fclose(v3);
    v8 = cJSON_Parse(v6);
    cJSON_Print(v8);
    ObjectItem = cJSON_GetObjectItem(v8, "dial_name");
    StringValue = (const char *)cJSON_GetStringValue(ObjectItem);
    strncpy(src, StringValue, 0xFFu);
    byte_40785F = 0;
    v11 = cJSON_GetObjectItem(v8, "blocks");
    ArraySize = cJSON_GetArraySize(v11);
    printf("Number of input json blocks=%d\n", ArraySize);
    if ( ArraySize > 0 )
    {
      v82 = v6;
      do
      {
        v13 = v7++;
        ArrayItem = cJSON_GetArrayItem(v11, v13);
        v15 = cJSON_GetObjectItem(ArrayItem, "cty");
        NumberValue = cJSON_GetNumberValue(v15);
        v16 = cJSON_GetObjectItem(ArrayItem, "ctx");
        v80 = cJSON_GetNumberValue(v16);
        v17 = cJSON_GetObjectItem(ArrayItem, "alnx");
        v79 = cJSON_GetNumberValue(v17);
        v18 = cJSON_GetObjectItem(ArrayItem, "posy");
        v78 = cJSON_GetNumberValue(v18);
        v19 = cJSON_GetObjectItem(ArrayItem, "posx");
        v77 = cJSON_GetNumberValue(v19);
        v20 = cJSON_GetObjectItem(ArrayItem, "height");
        v76 = cJSON_GetNumberValue(v20);
        v21 = cJSON_GetObjectItem(ArrayItem, "width");
        v75 = cJSON_GetNumberValue(v21);
        v22 = cJSON_GetObjectItem(ArrayItem, "colsp");
        v23 = (const char *)cJSON_GetStringValue(v22);
        v24 = cJSON_GetObjectItem(ArrayItem, "reuse");
        v74 = cJSON_GetNumberValue(v24);
        v25 = cJSON_GetObjectItem(ArrayItem, "fname");
        v26 = (const char *)cJSON_GetStringValue(v25);
        v27 = cJSON_GetObjectItem(ArrayItem, "frms");
        v72 = cJSON_GetNumberValue(v27);
        v28 = cJSON_GetObjectItem(ArrayItem, "type");
        v29 = (char *)cJSON_GetStringValue(v28);
        sub_401F40(
          v29,
          (int)v72,
          v26,
          (unsigned int)(int)v74,
          v23,
          (int)v75,
          (int)v76,
          (int)v77,
          (int)v78,
          (int)v79,
          (int)v80,
          (int)NumberValue);
      }
      while ( ArraySize != v7 );
      v6 = v82;
    }
    v30 = 0;
    free(v6);
    v31 = (unsigned __int8)byte_407744;
    printf("--------------- %s composer %s ---------------\n", "HK89", "v1.9.6");
    v32 = 20 * v31 + 4;
    if ( byte_407744 )
    {
      v30 = 0;
      v33 = (unsigned __int8 *)::ptr + 1;
      do
      {
        v34 = *v33;
        v33 += 120;
        v30 += v34;
      }
      while ( (char *)::ptr + 120 * (unsigned int)(unsigned __int8)byte_407744 + 1 != (char *)v33 );
    }
    printf("Compilation of images... (pl_num=%d)\n", v30);
    if ( byte_407744 )
    {
      v35 = v32 + 4 * v30;
      v73 = v30;
      v36 = ::ptr;
      v37 = 0;
      v38 = 0;
      v39 = 0;
      while ( 1 )
      {
        v42 = 120 * v38;
        v43 = (__int64)v36 + 120 * v38;
        *(_QWORD *)(v43 + 40) = strstr(*(const char **)(v43 + 8), ".png") ? sub_402760(v43) : (char *)sub_402E70(v43);
        v36 = ::ptr;
        v44 = (char *)::ptr + v42;
        if ( !*(_QWORD *)((char *)::ptr + v42 + 40) )
          break;
        v45 = (unsigned __int8)v44[1];
        if ( (_BYTE)v45 == 1 )
        {
          v40 = (unsigned __int16)v37++;
          ptr[v40] = *((_DWORD *)v44 + 27);
        }
        else if ( (_BYTE)v45 )
        {
          v46 = (int *)(v44 + 48);
          v47 = v37;
          do
          {
            v48 = *v46;
            v49 = (unsigned __int16)v47++;
            ++v46;
            ptr[v49] = v48;
          }
          while ( (_WORD)v47 != (_WORD)v37 + (unsigned __int8)v45 );
          v37 += v45;
        }
        v41 = v35 + v39;
        ++v38;
        v39 += *((_DWORD *)v44 + 27);
        *((_DWORD *)v44 + 28) = v41;
        if ( (unsigned __int8)byte_407744 <= (int)v38 )
        {
          v30 = v73;
          goto LABEL_27;
        }
      }
      printf("Failed to load file \"%s\"!(NULL ptr)\n", *((const char **)v44 + 1));
      return 0;
    }
    else
    {
LABEL_27:
      v51 = 0;
      puts("Compilation of blocks...");
      v52 = 0;
      if ( byte_407744 )
      {
        v53 = (char *)&unk_406340;
        v54 = 0;
        v51 = 0;
        v55 = 0;
        while ( 1 )
        {
          v58 = (char *)::ptr + v54;
          v59 = *((unsigned __int8 *)::ptr + v54);
          v53[15] = v59;
          v60 = *((unsigned __int16 *)v58 + 14);
          v61 = *((_DWORD *)v58 + 28);
          *((_WORD *)v53 + 5) = v60;
          v62 = *((unsigned __int16 *)v58 + 15);
          *((_WORD *)v53 + 6) = v62;
          v63 = *((unsigned __int16 *)v58 + 12);
          *((_WORD *)v53 + 3) = v63;
          v64 = *((unsigned __int16 *)v58 + 13);
          *(_DWORD *)v53 = v61;
          *((_WORD *)v53 + 4) = v64;
          v65 = (unsigned __int8)v58[1];
          v53[4] = v51;
          v53[14] = v65;
          *((_WORD *)v53 + 8) = (unsigned __int8)v58[32] | 0x400;
          v53[18] = v58[33];
          v53[19] = v58[34];
          if ( (unsigned __int16)v63 > 0x1E6u || (unsigned __int16)v64 > 0x1234u || (unsigned int)(v61 - 1) > 0xFFFFFFFD )
            break;
          if ( *((_DWORD *)v58 + 5) == 2 )
            v53[15] = v59 | 0x80;
          v51 += v65;
          v56 = "RGB ";
          if ( v53[15] < 0 )
            v56 = "RGBA";
          v54 += 120;
          v53 += 20;
          v71 = v64;
          v57 = v55++;
          printf(
            "%2d. blokk: type=0x%02X, %s px=%3d, py=%3d, sx=%3d, sy=%3d, pic offs=0x%04X\n",
            v57,
            v59,
            v56,
            v60,
            v62,
            v63,
            v71,
            v61);
          v52 = (unsigned __int8)byte_407744;
          if ( (unsigned __int8)byte_407744 <= v55 )
            goto LABEL_38;
        }
        puts("Invalid address, aborting!");
        return 0;
      }
      else
      {
LABEL_38:
        printf("Filling in the info table... (num_dblk=%d,num_pl=%d,par3=%d\n", v52, v51, 2);
        v66 = 0;
        word_407740 = v51;
        byte_407743 = 2;
        byte_407742 = byte_407744;
        v67 = strncpy(dest, src, 0x80u);
        v68 = strncat(v67, ".bin", 128 - (strlen(v67) + 1));
        v69 = fopen(v68, "wb");
        fwrite(&word_407740, 4u, 1u, v69);
        fwrite(&unk_406340, 0x14u, (unsigned __int8)byte_407744, v69);
        fwrite(ptr, (unsigned int)(4 * v30), 1u, v69);
        printf(
          "The number of written blocks is %d, their total size is %d bytes.\n",
          (unsigned __int8)byte_407744,
          20 * (unsigned __int8)byte_407744);
        while ( (unsigned __int8)byte_407744 > (int)v66 )
        {
          v70 = (char *)::ptr + 120 * v66++;
          result = sub_401B30((__int64)v70, v69);
          if ( !(_DWORD)result )
            return result;
        }
        fclose(v69);
        return 1;
      }
    }
  }
}
// 401050: using guessed type __int64 __fastcall cJSON_GetObjectItem(_QWORD, _QWORD);
// 401060: using guessed type __int64 __fastcall cJSON_Print(_QWORD);
// 4010C0: using guessed type __int64 __fastcall cJSON_Parse(_QWORD);
// 4010E0: using guessed type __int64 __fastcall cJSON_GetArraySize(_QWORD);
// 401150: using guessed type __int64 __fastcall cJSON_GetArrayItem(_QWORD, _QWORD);
// 401180: using guessed type double __fastcall cJSON_GetNumberValue(_QWORD);
// 4011C0: using guessed type __int64 __fastcall cJSON_GetStringValue(_QWORD);
// 407740: using guessed type __int16 word_407740;
// 407742: using guessed type char byte_407742;
// 407743: using guessed type char byte_407743;
// 407744: using guessed type char byte_407744;
// 40785F: using guessed type char byte_40785F;

//----- (0000000000401910) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall __noreturn start(__int64 a1, __int64 a2, void (*a3)(void))
{
  __int64 v3; // rax
  int v4; // esi
  __int64 v5; // [rsp-8h] [rbp-8h] BYREF
  char *retaddr; // [rsp+0h] [rbp+0h] BYREF

  v4 = v5;
  v5 = v3;
  _libc_start_main((int (*)(int, char **, char **))main, v4, &retaddr, (void (*)(void))init, fini, a3, &v5);
  __halt();
}
// 40191A: positive sp value 8 has been found
// 401921: variable 'v3' is possibly undefined

//----- (0000000000401950) ----------------------------------------------------
void *sub_401950()
{
  return &unk_4062F0;
}

//----- (00000000004019C0) ----------------------------------------------------
void *sub_4019C0()
{
  void *result; // rax

  if ( !byte_406300 )
  {
    result = sub_401950();
    byte_406300 = 1;
  }
  return result;
}
// 406300: using guessed type char byte_406300;

//----- (00000000004019F0) ----------------------------------------------------
__int64 sub_4019F0()
{
  return 0;
}
// 4019F0: using guessed type __int64 sub_4019F0();

//----- (0000000000401A00) ----------------------------------------------------
__int64 __fastcall sub_401A00(__int64 a1, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // edx
  __int64 v7; // rcx
  int v8; // edx
  __int64 v9; // rax
  unsigned __int8 v10; // r10
  char v11; // bl
  unsigned __int8 v12; // r11
  __int64 v13; // rdx
  char v14; // bp
  unsigned __int8 v15; // r12
  unsigned __int8 v16; // r13
  char v17; // r14
  bool v18; // si
  char v19; // r8
  char v20; // cl
  __int64 result; // rax
  char v22; // dl

  v6 = a2 * (a4 * a5 + a3);
  v7 = v6;
  v8 = a2 + v6;
  v9 = v8;
  v10 = *(_BYTE *)(a1 + v7 + 2);
  v11 = *(_BYTE *)(a1 + v7);
  v12 = *(_BYTE *)(a1 + v7 + 1);
  v13 = a2 + v8;
  v14 = *(_BYTE *)(a1 + v9);
  v15 = *(_BYTE *)(a1 + v13 + 2);
  v16 = *(_BYTE *)(a1 + v13 + 1);
  v17 = *(_BYTE *)(a1 + v13);
  v18 = *(_BYTE *)(a1 + v9 + 2) == v10 && *(_BYTE *)(a1 + v9 + 1) == v12;
  if ( !a6 )
  {
    if ( v11 == v14 && v18 )
      return (v10 == v15 && v12 == v16) & (unsigned __int8)(v11 == v17);
    return 0;
  }
  v19 = *(_BYTE *)(a1 + v9 + 3);
  v20 = *(_BYTE *)(a1 + v7 + 3);
  result = 0;
  v22 = *(_BYTE *)(a1 + v13 + 3);
  if ( !v18 )
    return result;
  if ( v11 != v14 || v20 != v19 || v10 != v15 || v12 != v16 )
    return 0;
  return (v11 == v17) & (unsigned __int8)(v20 == v22);
}

//----- (0000000000401AE0) ----------------------------------------------------
int __fastcall sub_401AE0(int a1)
{
  unsigned __int8 *v1; // rax

  v1 = (unsigned __int8 *)ptr + 120 * a1;
  return printf(
           "block%2d: type=%2d; posx=%3d; posy=%3d; sizex=%3d; sizey=%3d; align=%d\n",
           a1,
           *v1,
           *((unsigned __int16 *)v1 + 14),
           *((unsigned __int16 *)v1 + 15),
           *((unsigned __int16 *)v1 + 12),
           *((unsigned __int16 *)v1 + 13),
           v1[32]);
}

//----- (0000000000401B30) ----------------------------------------------------
__int64 __fastcall sub_401B30(__int64 a1, FILE *a2)
{
  size_t v3; // rsi

  v3 = *(unsigned int *)(a1 + 108);
  if ( (unsigned int)v3 > 0x177000 )
  {
    printf("append_pix: picture is too large! (%d byte)\n", v3);
    return 0;
  }
  else
  {
    fwrite(*(const void **)(a1 + 40), v3, 1u, a2);
    printf("Added to output %d bytes\n", *(_DWORD *)(a1 + 108));
    return 1;
  }
}

//----- (0000000000401B80) ----------------------------------------------------
__int64 __fastcall sub_401B80(char *s1)
{
  __int64 i; // rbx

  for ( i = 0; i != 27; ++i )
  {
    if ( !strcmp(s1, (&off_406140)[2 * i]) )
      return (unsigned __int8)byte_406148[16 * (int)i];
  }
  return 0;
}
// 406140: using guessed type char *off_406140;

//----- (0000000000401F40) ----------------------------------------------------
__int64 __fastcall sub_401F40(
        char *a1,
        char a2,
        const char *a3,
        __int64 a4,
        const char *a5,
        __int16 a6,
        __int16 a7,
        __int16 a8,
        __int16 a9,
        char a10,
        char a11,
        char a12)
{
  char v14; // r15
  char v15; // bl
  size_t v16; // rbp
  void *v17; // rax
  __int64 v18; // rbx
  char *v19; // rax
  void *v22; // [rsp+8h] [rbp-40h]

  v14 = sub_401B80(a1);
  v15 = byte_407744;
  v16 = 120 * ((unsigned __int8)byte_407744 + 1LL);
  v17 = realloc(ptr, v16);
  if ( !v17 )
  {
    puts("Allocation error!");
    exit(0);
  }
  v22 = v17;
  printf("New list_dblock size=%d\n", v16);
  byte_407744 = v15 + 1;
  v18 = (__int64)v22 + v16 - 120;
  ptr = v22;
  *(_BYTE *)v18 = v14;
  *(_DWORD *)(v18 + 20) = (strcmp(a5, "RGBA") == 0) + 1;
  v19 = strdup(a3);
  *(_WORD *)(v18 + 24) = a6;
  *(_QWORD *)(v18 + 8) = v19;
  *(_BYTE *)(v18 + 1) = a2;
  *(_WORD *)(v18 + 28) = a8;
  *(_WORD *)(v18 + 30) = a9;
  *(_WORD *)(v18 + 26) = a7;
  *(_BYTE *)(v18 + 32) = a10;
  *(_BYTE *)(v18 + 33) = a11;
  *(_BYTE *)(v18 + 34) = a12;
  return 0;
}
// 407744: using guessed type char byte_407744;

//----- (0000000000402100) ----------------------------------------------------
int __fastcall sub_402100(
        char a1,
        unsigned __int8 a2,
        int a3,
        unsigned __int8 a4,
        unsigned __int8 a5,
        int a6,
        int a7,
        __int64 a8,
        int *a9,
        const char *a10)
{
  int result; // eax
  int v12; // r9d

  result = a3;
  v12 = *a9;
  if ( *a9 )
  {
    if ( v12 > 0 )
      *a9 = v12 - 1;
    LODWORD(a8) = (_DWORD)a8 == 0 ? 45 : 65;
    return printf(
             "first %s: j=%3d, cnt=%3d, R:%02X G:%02X B:%02X %c:%02X\n",
             a10,
             a6,
             a1 & 0x7F,
             a2,
             (unsigned __int8)result,
             a4,
             a8,
             a5);
  }
  return result;
}

//----- (0000000000402170) ----------------------------------------------------
_BYTE *__fastcall sub_402170(unsigned __int8 a1, __int16 a2, __int16 a3, char a4, int a5)
{
  _BYTE *v5; // rax
  __int16 v6; // dx
  __int64 v7; // rsi
  _BYTE *result; // rax

  v5 = (_BYTE *)qword_406328;
  v6 = (a1 >> 3) | (8 * a2) & 0x7E0 | (a3 << 8) & 0xF800;
  v7 = qword_406328 + 1;
  if ( a5 )
  {
    ++qword_406328;
    *v5 = a4;
    v5 = (_BYTE *)qword_406328;
    v7 = qword_406328 + 1;
  }
  qword_406328 = v7;
  *v5 = HIBYTE(v6);
  result = (_BYTE *)qword_406328++;
  *result = v6;
  return result;
}
// 406328: using guessed type __int64 qword_406328;

//----- (00000000004021E0) ----------------------------------------------------
__int64 __fastcall sub_4021E0(__int64 a1, __int64 a2, int a3)
{
  char *v3; // r8
  __int64 v4; // r13
  __int64 i; // rbx
  int v6; // edx
  char v8[32]; // [rsp+0h] [rbp-848h] BYREF
  char dest[2088]; // [rsp+20h] [rbp-828h] BYREF

  dest[0] = 0;
  v3 = dest;
  if ( a3 <= 0 )
  {
LABEL_7:
    printf("magic found for: %s\n", v3);
    return 1;
  }
  else
  {
    v4 = (unsigned int)(a3 - 1);
    for ( i = 0; ; ++i )
    {
      v6 = *(unsigned __int8 *)(a1 + i);
      if ( (_BYTE)v6 != *(_BYTE *)(a2 + i) )
        break;
      sprintf(v8, "%02X, ", v6);
      v3 = strcat(dest, v8);
      if ( v4 == i )
        goto LABEL_7;
    }
    return 0;
  }
}

//----- (0000000000402290) ----------------------------------------------------
char *__fastcall sub_402290(__int64 a1, int *a2, int a3, int a4, int a5)
{
  unsigned __int8 v5; // r13
  unsigned __int8 v6; // r14
  char *v7; // r15
  int v8; // ebp
  char *v10; // rax
  char *v11; // rdx
  char v12; // al
  int v13; // r9d
  int v14; // ebp
  int v15; // r12d
  unsigned __int8 *v16; // rbx
  unsigned __int8 v17; // r11
  unsigned __int8 v18; // r10
  bool v19; // al
  __int64 v20; // r10
  int v21; // eax
  char v22; // cl
  __int16 v23; // dx
  __int16 v24; // si
  unsigned __int8 v25; // di
  char v26; // al
  int v27; // eax
  int v28; // edx
  bool v29; // zf
  int v30; // eax
  unsigned int v31; // esi
  int v32; // eax
  unsigned __int8 v34; // [rsp+Fh] [rbp-89h]
  int v37; // [rsp+14h] [rbp-84h]
  unsigned __int8 v38; // [rsp+18h] [rbp-80h]
  __int64 v39; // [rsp+18h] [rbp-80h]
  char *ptr; // [rsp+28h] [rbp-70h]
  __int64 v42; // [rsp+30h] [rbp-68h]
  int v43; // [rsp+3Ch] [rbp-5Ch]
  int v44; // [rsp+40h] [rbp-58h]
  int v45; // [rsp+44h] [rbp-54h]
  __int64 v46; // [rsp+48h] [rbp-50h]
  int v47; // [rsp+50h] [rbp-48h]
  char v48; // [rsp+54h] [rbp-44h]
  char v49; // [rsp+55h] [rbp-43h]
  unsigned __int8 v50; // [rsp+56h] [rbp-42h]
  unsigned __int8 v51; // [rsp+57h] [rbp-41h]

  v8 = 4 * a4;
  v44 = 4 * a4 + 4098;
  v10 = (char *)malloc(v44);
  ptr = v10;
  if ( v10 )
  {
    memset(v10, 0, v8);
    v11 = &ptr[v8];
    qword_406328 = (__int64)v11;
    if ( a4 > 0 )
    {
      v45 = 0;
      v46 = (unsigned int)(a4 - 1);
      v42 = 0;
      v47 = a5;
      while ( 1 )
      {
        v12 = (_BYTE)v11 - (_BYTE)ptr;
        v43 = (_DWORD)v11 - (_DWORD)ptr;
        if ( a3 > 0 )
          break;
        v8 = (_DWORD)v11 - (_DWORD)ptr;
LABEL_21:
        if ( v44 - v8 <= 4095 )
        {
          v44 += 4096;
          ptr = (char *)realloc(ptr, v44);
          v12 = v8;
          v11 = &ptr[v8];
          qword_406328 = (__int64)v11;
        }
        *(_DWORD *)&ptr[4 * v42] = v43;
        v45 += a3;
        if ( v46 == v42 )
          goto LABEL_42;
        ++v42;
      }
      v13 = v47;
      v14 = 0;
      v15 = 0;
      v37 = 0;
      v16 = (unsigned __int8 *)(a1 + 4 * v45);
      while ( 1 )
      {
        v17 = v6;
        v18 = v5;
        v6 = v16[2];
        v5 = v16[1];
        v38 = v34;
        v34 = *v16;
        v49 = v48;
        v48 = v16[3];
        if ( !v37 )
        {
          if ( a3 - v14 > 2 && (unsigned int)sub_401A00(a1, 4, v14, v42, a3, v13) )
          {
            v7 = (char *)qword_406328;
            v37 = 1;
            ++v15;
            ++qword_406328;
            *v7 = -127;
          }
          else
          {
            if ( v14 && *v7 != 127 )
            {
              v26 = *v7 + 1;
            }
            else
            {
              v7 = (char *)qword_406328;
              ++v15;
              ++qword_406328;
              v26 = 1;
              *v7 = 0;
            }
            *v7 = v26;
          }
          sub_402170(v6, v5, v34, v48, v13);
          v15 += (v13 != 0) + 2;
          goto LABEL_10;
        }
        v19 = v5 == v18 && v17 == v6;
        if ( v13 )
          break;
        if ( v34 == v38 && v19 )
        {
LABEL_33:
          if ( *v7 == -1 )
          {
            v7 = (char *)qword_406328++;
            if ( a3 - v14 <= 2 )
            {
              v37 = 0;
              LOBYTE(v28) = 1;
            }
            else
            {
              v51 = v18;
              v50 = v17;
              v27 = sub_401A00(a1, 4, v14, v42, a3, v13);
              v17 = v50;
              v18 = v51;
              v28 = v27 == 0 ? -255 : -127;
              v29 = v27 == 0;
              v30 = 0;
              if ( !v29 )
                v30 = v37;
              v37 = v30;
            }
            *v7 = v28;
            v22 = v49;
            v24 = v18;
            v25 = v17;
            v23 = v38;
            goto LABEL_19;
          }
          ++*v7;
LABEL_10:
          ++v14;
          v16 += 4;
          if ( a3 == v14 )
            goto LABEL_20;
        }
        else
        {
LABEL_15:
          v7 = (char *)qword_406328;
          v20 = qword_406328 + 1;
          if ( a3 - v14 > 2 && (v39 = qword_406328 + 1, v21 = sub_401A00(a1, 4, v14, v42, a3, v13), v20 = v39, v21) )
          {
            qword_406328 = v39;
            *v7 = -127;
          }
          else
          {
            qword_406328 = v20;
            v37 = 0;
            *v7 = 1;
          }
          v22 = v48;
          v23 = v34;
          v24 = v5;
          v25 = v6;
LABEL_19:
          sub_402170(v25, v24, v23, v22, v13);
          ++v14;
          v16 += 4;
          v15 += (v13 != 0) + 3;
          if ( a3 == v14 )
          {
LABEL_20:
            v11 = (char *)qword_406328;
            v43 |= v15 << 21;
            v12 = qword_406328 - (_BYTE)ptr;
            v8 = qword_406328 - (_DWORD)ptr;
            goto LABEL_21;
          }
        }
      }
      if ( !v19 || v34 != v38 || v48 != v49 )
        goto LABEL_15;
      goto LABEL_33;
    }
    v12 = v8;
LABEL_42:
    *a2 = v8;
    if ( (v12 & 3) != 0 )
    {
      v31 = ((unsigned int)(v8 >> 31) >> 30) - ((((unsigned int)(v8 >> 31) >> 30) + (_BYTE)v8) & 3) + 4;
      v32 = 0;
      while ( 1 )
      {
        ++v32;
        qword_406328 = (__int64)(v11 + 1);
        *v11 = 0;
        if ( v31 == v32 )
          break;
        v11 = (char *)qword_406328;
      }
      *a2 += v31;
    }
  }
  return ptr;
}
// 40239B: variable 'v13' is possibly undefined
// 40240C: variable 'v6' is possibly undefined
// 40240F: variable 'v5' is possibly undefined
// 40241C: variable 'v34' is possibly undefined
// 40242C: variable 'v48' is possibly undefined
// 402564: variable 'v7' is possibly undefined
// 406328: using guessed type __int64 qword_406328;

//----- (0000000000402760) ----------------------------------------------------
char *__fastcall sub_402760(__int64 a1)
{
  const char *v1; // r12
  int v2; // eax
  unsigned __int8 v3; // dl
  char *v4; // rbp
  int v5; // r12d
  char *v6; // r15
  int v7; // r13d
  void *v8; // rax
  char *v9; // r13
  int v11; // esi
  __int64 v12; // r12
  __int64 v13; // rbp
  char *v14; // rsi
  int v15; // eax
  void *ptr; // [rsp+0h] [rbp-1F8h]
  int v17; // [rsp+Ch] [rbp-1ECh]
  int v18; // [rsp+10h] [rbp-1E8h]
  _BOOL4 v19; // [rsp+14h] [rbp-1E4h]
  int v20; // [rsp+18h] [rbp-1E0h]
  __int64 v21; // [rsp+18h] [rbp-1E0h]
  int v22; // [rsp+28h] [rbp-1D0h]
  int v23; // [rsp+2Ch] [rbp-1CCh]
  int v24; // [rsp+34h] [rbp-1C4h]
  char *v25; // [rsp+38h] [rbp-1C0h]
  char src[2]; // [rsp+42h] [rbp-1B6h] BYREF
  int v27; // [rsp+44h] [rbp-1B4h] BYREF
  char v28[5]; // [rsp+4Bh] [rbp-1ADh] BYREF
  _DWORD v29[28]; // [rsp+50h] [rbp-1A8h] BYREF
  char dest[256]; // [rsp+C0h] [rbp-138h] BYREF
  char v31; // [rsp+1C0h] [rbp-38h]

  v1 = *(const char **)(a1 + 8);
  strcpy(v28, ".png");
  memset(v29, 0, 0x68u);
  v29[2] = 1;
  v2 = strlen(v1);
  v3 = *(_BYTE *)(a1 + 1);
  if ( v1[v2 - 1] == 47 )
  {
    if ( v3 <= 1u )
      return 0;
    v23 = 0;
    v4 = dest;
    v18 = v3;
    v17 = 1;
  }
  else
  {
    v4 = dest;
    if ( v3 <= 1u )
    {
      strncpy(dest, v1, 0x100u);
      v31 = 0;
      v18 = 1;
      v23 = 0;
    }
    else
    {
      strncpy(dest, v1, 0x100u);
      v31 = 0;
      v18 = 1;
      v23 = 1;
    }
    v17 = 0;
  }
  v5 = 0;
  v19 = *(_DWORD *)(a1 + 20) == 2;
  v6 = 0;
  do
  {
    while ( v17 )
    {
      strncpy(v4, *(const char **)(a1 + 8), 0x7Fu);
      src[0] = v5 + 48;
      src[1] = 0;
      strncat(v4, src, 0x7Fu);
      strncat(v4, v28, 0x7Fu);
      if ( (unsigned int)png_image_begin_read_from_file(v29, v4) )
        goto LABEL_10;
LABEL_7:
      if ( v18 == ++v5 )
        goto LABEL_15;
    }
    if ( !(unsigned int)png_image_begin_read_from_file(v29, v4) )
      goto LABEL_7;
LABEL_10:
    v7 = v29[3];
    v29[5] = 3;
    v20 = v29[4];
    v8 = malloc((unsigned int)(4 * v29[3] * v29[4]));
    *(_WORD *)(a1 + 24) = v7;
    ptr = v8;
    if ( v8 && (unsigned int)png_image_finish_read(v29, 0, v8, 0, 0) )
    {
      if ( v23 )
      {
        v11 = *(unsigned __int8 *)(a1 + 1);
        *(_DWORD *)(a1 + 108) = 0;
        v22 = v20 / v11;
        v24 = v5;
        v12 = (__int64)ptr;
        v25 = v4;
        v13 = 0;
        v21 = (v19 + 3) * v20 / v11 * v7;
        do
        {
          v14 = sub_402290(v12, &v27, *(unsigned __int16 *)(a1 + 24), v22, v19);
          v6 = (char *)realloc(v6, (unsigned int)(*(_DWORD *)(a1 + 108) + v27));
          memcpy(&v6[*(unsigned int *)(a1 + 108)], v14, v27);
          free(v14);
          v15 = v27;
          *(_DWORD *)(a1 + 108) += v27;
          v12 += v21;
          *(_DWORD *)(a1 + 4 * v13++ + 48) = v15;
        }
        while ( *(unsigned __int8 *)(a1 + 1) > (int)v13 );
        v5 = v24;
        v4 = v25;
      }
      else
      {
        v6 = sub_402290((__int64)ptr, &v27, *(unsigned __int16 *)(a1 + 24), *(unsigned __int16 *)(a1 + 26), v19);
        *(_DWORD *)(a1 + 108) = v27;
      }
    }
    ++v5;
    free(ptr);
  }
  while ( v18 != v5 );
LABEL_15:
  v9 = v6;
  png_image_free(v29);
  return v9;
}
// 402996: conditional instruction was optimized away because esi.4 is in (1..FF)
// 401140: using guessed type __int64 __fastcall png_image_begin_read_from_file(_QWORD, _QWORD);
// 4011A0: using guessed type __int64 __fastcall png_image_finish_read(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 401230: using guessed type __int64 __fastcall png_image_free(_QWORD);

//----- (0000000000402AC0) ----------------------------------------------------
__int64 __fastcall sub_402AC0(unsigned __int8 *a1, __int64 a2, _DWORD *a3, int a4, int a5, int a6, int a7)
{
  unsigned __int8 v7; // r15
  int v11; // ebx
  int v12; // r12d
  int v13; // r10d
  int v14; // esi
  int v15; // edi
  unsigned __int8 *v16; // rcx
  __int16 v17; // dx
  int v18; // ecx
  int v19; // esi
  __int16 v20; // ax
  unsigned __int8 *v21; // r8
  unsigned __int16 v22; // ax
  int v23; // r8d
  char v24; // dl
  __int64 v25; // rax
  int v26; // esi
  unsigned __int8 v28; // di
  int v29; // esi
  unsigned __int16 v30; // dx
  int v31; // r9d
  char v32; // r8
  unsigned __int8 v33; // dl
  unsigned int v34; // r9d
  int v35; // ecx
  int v36; // edi
  int v38; // [rsp+18h] [rbp-58h]
  int v39; // [rsp+1Ch] [rbp-54h]
  int v40; // [rsp+1Ch] [rbp-54h]
  int v41; // [rsp+28h] [rbp-48h]

  v11 = 0;
  v12 = *(unsigned __int16 *)a1;
  printf(
    "      decode_rgba_buff: offs=0: %02X %02X %02X %02X sorok:(4*%d) 0.sor offs=%d ww=%d hh=%d\n",
    *a1,
    a1[1],
    a1[2],
    a1[3],
    (unsigned __int16)v12 >> 2,
    v12,
    a4,
    a5);
  v38 = 0;
  if ( a5 > 0 )
  {
    while ( 1 )
    {
      v13 = 0;
      if ( a4 > 0 )
        break;
LABEL_17:
      if ( a7 )
        printf("%2d.sor %d pixel\n", v38, v13);
      if ( a5 == ++v38 )
        goto LABEL_20;
    }
    while ( 1 )
    {
      v14 = v12 + 1;
      v15 = a1[v12];
      v16 = &a1[v12 + 1];
      if ( (_BYTE)v15 )
      {
        v17 = *v16;
        if ( (v15 & 0x80u) != 0 )
        {
          v28 = v15 & 0x7F;
          if ( a6 )
          {
            v14 = v12 + 2;
            v7 = *v16;
            v16 = &a1[v12 + 2];
            v17 = *v16;
          }
          v12 = v14 + 2;
          v29 = v28;
          v30 = v16[1] | (unsigned __int16)(v17 << 8);
          v31 = v30;
          v32 = 8 * v30;
          v33 = HIBYTE(v30) & 0xF8;
          v34 = (v31 >> 3) & 0xFFFFFFFC;
          if ( v28 )
          {
            v35 = 0;
            do
            {
              while ( 1 )
              {
                v36 = v11 + 3;
                *(_BYTE *)(a2 + v11) = v33;
                *(_BYTE *)(a2 + v11 + 1) = v34;
                *(_BYTE *)(a2 + v11 + 2) = v32;
                if ( !a6 )
                  break;
                ++v35;
                v11 += 4;
                *(_BYTE *)(a2 + v36) = v7;
                if ( v35 == v29 )
                  goto LABEL_31;
              }
              ++v35;
              v11 += 3;
            }
            while ( v35 != v29 );
          }
LABEL_31:
          v13 += v29;
          if ( a7 )
          {
            v39 = v13;
            printf(
              "ism   : cnt=%d r=%d g=%d b=%d a=%d j=%d i=%d\n",
              v29,
              v33,
              (unsigned __int8)v34,
              v32 & 0xF8,
              v7,
              v38,
              v13);
            v13 = v39;
          }
          goto LABEL_16;
        }
      }
      else if ( a7 )
      {
        v41 = v13;
        puts("cnt=0 , exiting...");
        v15 = 1;
        v13 = v41;
        v17 = a1[v14];
      }
      else
      {
        v17 = *v16;
        v15 = 1;
      }
      ++v12;
      v18 = v11;
      v19 = 0;
      while ( 1 )
      {
        if ( a6 )
        {
          ++v12;
          v7 = v17;
          v21 = &a1[v12];
          v20 = *v21;
        }
        else
        {
          v20 = v17;
          v21 = &a1[v12];
        }
        v12 += 2;
        v22 = v21[1] | (unsigned __int16)(v20 << 8);
        *(_BYTE *)(a2 + v11) = HIBYTE(v22) & 0xF8;
        v23 = v22;
        v24 = 8 * v22;
        v25 = v11 + 1;
        v11 += 3;
        *(_BYTE *)(a2 + v25) = (v23 >> 3) & 0xFC;
        *(_BYTE *)(a2 + v18 + 2) = v24;
        if ( a6 )
        {
          *(_BYTE *)(a2 + v11) = v7;
          v11 = v18 + 4;
        }
        if ( ++v19 == v15 )
          break;
        v18 = v11;
        v17 = a1[v12];
      }
      v13 += v19;
      if ( a7 )
      {
        v40 = v13;
        printf("egyedi: cnt=%d j=%d i=%d\n", v19, v38, v13);
        v13 = v40;
      }
LABEL_16:
      if ( a4 <= v13 )
        goto LABEL_17;
    }
  }
LABEL_20:
  *a3 = v11;
  if ( (v12 & 3) != 0 )
  {
    v26 = v12;
    v12 = v12 - (v12 & 3) + 4;
    printf("align %d to %d\n", v26, v12);
  }
  return (unsigned int)v12;
}
// 402BE3: variable 'v7' is possibly undefined

//----- (0000000000402E30) ----------------------------------------------------
__int64 __fastcall sub_402E30(FILE *stream)
{
  unsigned int v1; // ebx

  fseek(stream, 0, 2);
  v1 = ftell(stream);
  fseek(stream, 0, 0);
  return v1;
}

//----- (0000000000402E70) ----------------------------------------------------
_WORD *__fastcall sub_402E70(__int64 a1)
{
  FILE *v1; // rax
  FILE *v2; // r12
  int v3; // ebp
  int v4; // esi
  _WORD *v5; // r13
  int v6; // eax
  int v7; // esi
  unsigned __int16 v8; // dx
  int v9; // edx
  int v10; // esi

  printf("load_encoded_file: fname=\"%s\"\n", *(const char **)(a1 + 8));
  v1 = fopen(*(const char **)(a1 + 8), "rb");
  if ( v1 )
  {
    v2 = v1;
    v3 = sub_402E30(v1);
    printf("file size = %d\n", v3);
    if ( v3 % 4 > 0 )
    {
      v4 = v3;
      v3 = v3 - v3 % 4 + 4;
      printf("align %d to %d\n", v4, v3);
    }
    v5 = calloc(v3, 1u);
    v6 = fread(v5, 1u, v3, v2);
    printf("readed = %d byte\n", v6);
    fclose(v2);
    v7 = (unsigned __int16)*v5;
    v8 = *v5 >> 2;
    *(_WORD *)(a1 + 26) = v8;
    printf("load_encoded_file: first line offs= %04X, -> height= %d\n", v7, v8);
    v9 = *(unsigned __int16 *)(a1 + 26);
    if ( (unsigned __int16)(v9 - 466) <= 1u )
    {
      v10 = 466;
      *(_WORD *)(a1 + 24) = 466;
    }
    else if ( (_WORD)v9 == 280 )
    {
      v10 = 280;
      *(_WORD *)(a1 + 24) = 280;
    }
    else
    {
      v10 = *(unsigned __int16 *)(a1 + 24);
    }
    *(_DWORD *)(a1 + 108) = v3;
    printf("sx = %d , sy = %d\n", v10, v9);
  }
  else
  {
    v5 = 0;
    puts("open error");
  }
  return v5;
}

//----- (0000000000403020) ----------------------------------------------------
void __fastcall init(unsigned int a1, __int64 a2, __int64 a3)
{
  signed __int64 v4; // rbp
  __int64 i; // rbx

  init_proc();
  v4 = &off_405DE8 - off_405DE0;
  if ( v4 )
  {
    for ( i = 0; i != v4; ++i )
      ((void (__fastcall *)(_QWORD, __int64, __int64))off_405DE0[i])(a1, a2, a3);
  }
}
// 405DE0: using guessed type __int64 (__fastcall *off_405DE0[2])();
// 405DE8: using guessed type __int64 (__fastcall *off_405DE8)();

//----- (0000000000403090) ----------------------------------------------------
void fini(void)
{
  ;
}

//----- (0000000000403098) ----------------------------------------------------
void term_proc()
{
  ;
}

// nfuncs=91 queued=23 decompiled=23 lumina nreq=0 worse=0 better=0
// ALL OK, 23 function(s) have been successfully decompiled
