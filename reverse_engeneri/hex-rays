/* This file was generated by the Hex-Rays decompiler version 9.1.0.250226.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 (**init_proc())(void);
__int64 sub_401020(); // weak
// __int64 __fastcall png_write_info(_QWORD, _QWORD); weak
// void free(void *ptr);
// char *strncpy(char *dest, const char *src, size_t n);
// char *strcpy(char *dest, const char *src);
// int mkdir(const char *path, __mode_t mode);
// int puts(const char *s);
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// int fclose(FILE *stream);
// __int64 __fastcall png_write_image(_QWORD, _QWORD); weak
// char *stpcpy(char *dest, const char *src);
// size_t strlen(const char *s);
// int printf(const char *format, ...);
// char *strrchr(const char *s, int c);
// __int64 __fastcall png_get_rowbytes(_QWORD, _QWORD); weak
// char *strncat(char *dest, const char *src, size_t n);
// __int64 __fastcall png_write_end(_QWORD, _QWORD); weak
// __int64 ftell(FILE *stream);
// __int64 __fastcall png_create_info_struct(_QWORD); weak
// void *malloc(size_t size);
// int fseek(FILE *stream, __int64 off, int whence);
// __int64 __fastcall png_init_io(_QWORD, _QWORD); weak
// FILE *fopen(const char *filename, const char *modes);
// __int64 __fastcall png_create_write_struct(_QWORD, _QWORD, _QWORD, _QWORD); weak
// char *strcat(char *dest, const char *src);
// int sprintf(char *s, const char *format, ...);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// __int64 __fastcall png_set_IHDR(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
void __fastcall __noreturn start(__int64 a1, __int64 a2, void (*a3)(void));
void *sub_401360();
void *sub_4013D0();
__int64 sub_401400(); // weak
__int64 __fastcall sub_4014E0(FILE *stream); // idb
int __fastcall sub_401520(char *src);
void __fastcall sub_4015D0(__int64 a1, __int64 a2, __int64 a3, int a4, int a5);
__int64 __fastcall sub_4016B0(unsigned __int16 *a1, __int64 a2, _DWORD *a3, int a4, int a5, int a6, int a7);
int __fastcall sub_401980(void *ptr, int a2, const char *a3);
char *__fastcall sub_4019C0(__int64 a1, int a2, int a3, int a4, int a5);
int __fastcall sub_401E40(const char *a1, int a2, int a3, int a4, __int64 a5);
char *__fastcall sub_402070(int a1, int a2);
__int64 __fastcall sub_4021A0(int a1);
int __fastcall sub_4021F0(char *a1, const char *a2);
int __fastcall sub_402370(unsigned int *a1, const char *a2, __int64 a3, int a4);
char *__fastcall sub_402520(_DWORD *a1, int a2);
void sub_402CC0();
void fini(void); // idb
void term_proc();
// int _libc_start_main(int (*main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end);
// __int64 _gmon_start__(void); weak

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN main;
_UNKNOWN init;
__int64 (__fastcall *off_404DF0[2])() = { &sub_401400, &sub_4013D0 }; // weak
__int64 (__fastcall *off_404DF8)() = &sub_4013D0; // weak
__int64 (*qword_405010)(void) = NULL; // weak
_UNKNOWN unk_4050F8; // weak
char byte_405100; // weak
void *ptr; // idb
_UNKNOWN unk_405140; // weak
char dest[252]; // idb
char *qword_538C20; // idb
int dword_538C30; // weak
char *qword_538C40; // idb
char filename[250]; // idb
char byte_538D5A; // weak


//----- (0000000000401000) ----------------------------------------------------
__int64 (**init_proc())(void)
{
  __int64 (**result)(void); // rax

  result = &_gmon_start__;
  if ( &_gmon_start__ )
    return (__int64 (**)(void))_gmon_start__();
  return result;
}
// 539040: using guessed type __int64 _gmon_start__(void);

//----- (0000000000401020) ----------------------------------------------------
__int64 sub_401020()
{
  return qword_405010();
}
// 401020: using guessed type __int64 sub_401020();
// 405010: using guessed type __int64 (*qword_405010)(void);

//----- (00000000004011E0) ----------------------------------------------------
__int64 __fastcall main(int a1, char **a2, char **a3)
{
  FILE *v3; // rax
  FILE *v4; // rbp
  int v5; // eax

  printf("HK89 dial decompressor %s\n", "v1.8");
  ptr = malloc(0x12C000u);
  if ( ptr )
  {
    dword_538C30 = 1228800;
    if ( a1 <= 1 )
    {
      puts("No .bin filename specified!");
      free(ptr);
      return 0;
    }
    else
    {
      qword_538C20 = a2[1];
      v3 = fopen(qword_538C20, "rb");
      v4 = v3;
      if ( v3 )
      {
        v5 = sub_4014E0(v3);
        if ( dword_538C30 < v5 )
        {
          printf("File too large (>%d Byte)\n", dword_538C30);
          free(ptr);
          return 0;
        }
        else
        {
          fread(ptr, v5, 1u, v4);
          fclose(v4);
          sub_401520(qword_538C20);
          byte_538D5A = *((_BYTE *)ptr + 2);
          sub_402CC0();
          free(ptr);
          return 1;
        }
      }
      else
      {
        printf("No such file! (%s)\n", qword_538C20);
        return 0;
      }
    }
  }
  else
  {
    printf("Unable to reserve %d byte memory!\n", (unsigned int)"v1.8");
    return 0;
  }
}
// 538C30: using guessed type int dword_538C30;
// 538D5A: using guessed type char byte_538D5A;

//----- (0000000000401320) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall __noreturn start(__int64 a1, __int64 a2, void (*a3)(void))
{
  __int64 v3; // rax
  int v4; // esi
  __int64 v5; // [rsp-8h] [rbp-8h] BYREF
  char *retaddr; // [rsp+0h] [rbp+0h] BYREF

  v4 = v5;
  v5 = v3;
  _libc_start_main((int (*)(int, char **, char **))main, v4, &retaddr, (void (*)(void))init, fini, a3, &v5);
  __halt();
}
// 40132A: positive sp value 8 has been found
// 401331: variable 'v3' is possibly undefined

//----- (0000000000401360) ----------------------------------------------------
void *sub_401360()
{
  return &unk_4050F8;
}

//----- (00000000004013D0) ----------------------------------------------------
void *sub_4013D0()
{
  void *result; // rax

  if ( !byte_405100 )
  {
    result = sub_401360();
    byte_405100 = 1;
  }
  return result;
}
// 405100: using guessed type char byte_405100;

//----- (0000000000401400) ----------------------------------------------------
__int64 sub_401400()
{
  return 0;
}
// 401400: using guessed type __int64 sub_401400();

//----- (00000000004014E0) ----------------------------------------------------
__int64 __fastcall sub_4014E0(FILE *stream)
{
  unsigned int v1; // ebx

  fseek(stream, 0, 2);
  v1 = ftell(stream);
  fseek(stream, 0, 0);
  return v1;
}

//----- (0000000000401520) ----------------------------------------------------
int __fastcall sub_401520(char *src)
{
  char v2[264]; // [rsp+0h] [rbp-108h] BYREF

  strncpy(v2, "_", 0xF6u);
  strncat(v2, src, 0xF6u);
  *strrchr(v2, 46) = 0;
  strcpy(dest, v2);
  return mkdir(v2, 0x1FFu);
}

//----- (00000000004015D0) ----------------------------------------------------
void __fastcall sub_4015D0(__int64 a1, __int64 a2, __int64 a3, int a4, int a5)
{
  int v5; // r15d
  int v7; // r14d
  signed int v8; // esi
  int v10; // edi
  int v12; // r8d
  __int64 v14; // rdx
  char *v15; // rcx
  __int16 v16; // ax
  char v17; // r10
  __int16 v18; // r9
  __int16 v19; // ax
  unsigned __int16 v20; // ax
  __int64 v21; // [rsp+0h] [rbp-38h]

  if ( a5 > 0 )
  {
    v5 = 3 * a4;
    v7 = 4 * (a4 - 1);
    v8 = 0;
    v10 = 0;
    v12 = 0;
    v21 = a2 + 4LL * (unsigned int)(a4 - 1) + 4;
    do
    {
      if ( a4 > 0 )
      {
        v14 = a2 + v12;
        v15 = (char *)(a1 + v8);
        do
        {
          v16 = (unsigned __int8)v15[1];
          v17 = *v15;
          v14 += 4;
          v15 += 3;
          v18 = v16 << 8;
          v19 = (unsigned __int8)*(v15 - 1);
          *(_BYTE *)(v14 - 1) = v17;
          v20 = v18 | v19;
          *(_BYTE *)(v14 - 4) = HIBYTE(v20) & 0xF8;
          *(_BYTE *)(v14 - 2) = 8 * v20;
          *(_BYTE *)(v14 - 3) = ((int)v20 >> 3) & 0xFC;
        }
        while ( v21 + v12 != v14 );
        v12 += v7 + 4;
        v8 += v5;
      }
      if ( (v8 & 3) != 0 )
        v8 = (v8 & 0xFFFFFFFC) + 4;
      ++v10;
    }
    while ( a5 != v10 );
  }
}

//----- (00000000004016B0) ----------------------------------------------------
__int64 __fastcall sub_4016B0(unsigned __int16 *a1, __int64 a2, _DWORD *a3, int a4, int a5, int a6, int a7)
{
  unsigned __int8 v7; // r15
  int v11; // ebx
  int v12; // r12d
  int v13; // r10d
  int v14; // esi
  int v15; // edi
  unsigned __int8 *v16; // rcx
  __int16 v17; // dx
  int v18; // ecx
  int v19; // esi
  __int16 v20; // ax
  unsigned __int8 *v21; // r8
  unsigned __int16 v22; // ax
  int v23; // r8d
  char v24; // dl
  __int64 v25; // rax
  unsigned int v26; // r12d
  unsigned __int8 v28; // di
  int v29; // esi
  unsigned __int16 v30; // dx
  int v31; // r9d
  char v32; // r8
  unsigned __int8 v33; // dl
  unsigned int v34; // r9d
  int v35; // ecx
  int v36; // edi
  unsigned __int8 *v37; // rcx
  int v39; // [rsp+10h] [rbp-58h]
  int v40; // [rsp+14h] [rbp-54h]
  int v41; // [rsp+14h] [rbp-54h]
  int v42; // [rsp+20h] [rbp-48h]

  v11 = 0;
  v12 = *a1;
  v39 = 0;
  if ( a5 > 0 )
  {
    while ( 1 )
    {
      v13 = 0;
      if ( a4 > 0 )
        break;
LABEL_17:
      if ( a5 == ++v39 )
        goto LABEL_18;
    }
    while ( 1 )
    {
      v14 = v12 + 1;
      v15 = *((unsigned __int8 *)a1 + v12);
      v16 = (unsigned __int8 *)a1 + v12 + 1;
      if ( (_BYTE)v15 )
      {
        v17 = *v16;
        if ( (v15 & 0x80u) != 0 )
        {
          v28 = v15 & 0x7F;
          if ( a6 )
          {
            v14 = v12 + 2;
            v7 = *v16;
            v16 = (unsigned __int8 *)a1 + v12 + 2;
            v17 = *v16;
          }
          v12 = v14 + 2;
          v29 = v28;
          v30 = v16[1] | (unsigned __int16)(v17 << 8);
          v31 = v30;
          v32 = 8 * v30;
          v33 = HIBYTE(v30) & 0xF8;
          v34 = (v31 >> 3) & 0xFFFFFFFC;
          if ( v28 )
          {
            v35 = 0;
            do
            {
              while ( 1 )
              {
                v36 = v11 + 3;
                *(_BYTE *)(a2 + v11) = v33;
                *(_BYTE *)(a2 + v11 + 1) = v34;
                *(_BYTE *)(a2 + v11 + 2) = v32;
                if ( !a6 )
                  break;
                ++v35;
                v11 += 4;
                *(_BYTE *)(a2 + v36) = v7;
                if ( v35 == v29 )
                  goto LABEL_29;
              }
              ++v35;
              v11 += 3;
            }
            while ( v35 != v29 );
          }
LABEL_29:
          v13 += v29;
          if ( a7 )
          {
            v40 = v13;
            printf(
              "ism   : cnt=%d r=%d g=%d b=%d a=%d j=%d i=%d\n",
              v29,
              v33,
              (unsigned __int8)v34,
              v32 & 0xF8,
              v7,
              v39,
              v13);
            v13 = v40;
          }
          goto LABEL_16;
        }
      }
      else if ( a7 )
      {
        v42 = v13;
        puts("cnt=0 , exiting...");
        v37 = (unsigned __int8 *)a1 + v14;
        v14 = v12 + 1;
        v15 = 1;
        v13 = v42;
        v17 = *v37;
      }
      else
      {
        v17 = *v16;
        v15 = 1;
      }
      v12 = v14;
      v18 = v11;
      v19 = 0;
      while ( 1 )
      {
        if ( a6 )
        {
          ++v12;
          v7 = v17;
          v21 = (unsigned __int8 *)a1 + v12;
          v20 = *v21;
        }
        else
        {
          v20 = v17;
          v21 = (unsigned __int8 *)a1 + v12;
        }
        v12 += 2;
        v22 = v21[1] | (unsigned __int16)(v20 << 8);
        *(_BYTE *)(a2 + v11) = HIBYTE(v22) & 0xF8;
        v23 = v22;
        v24 = 8 * v22;
        v25 = v11 + 1;
        v11 += 3;
        *(_BYTE *)(a2 + v25) = (v23 >> 3) & 0xFC;
        *(_BYTE *)(a2 + v18 + 2) = v24;
        if ( a6 )
        {
          *(_BYTE *)(a2 + v11) = v7;
          v11 = v18 + 4;
        }
        if ( ++v19 == v15 )
          break;
        v18 = v11;
        v17 = *((unsigned __int8 *)a1 + v12);
      }
      v13 += v19;
      if ( a7 )
      {
        v41 = v13;
        printf("unique: cnt=%d j=%d i=%d\n", v19, v39, v13);
        v13 = v41;
      }
LABEL_16:
      if ( a4 <= v13 )
        goto LABEL_17;
    }
  }
LABEL_18:
  *a3 = v11;
  v26 = v12 - (((v12 & 1) == 0) - 1);
  if ( (v26 & 3) != 0 )
    v26 += 2;
  return v26;
}
// 401793: variable 'v7' is possibly undefined

//----- (0000000000401980) ----------------------------------------------------
int __fastcall sub_401980(void *ptr, int a2, const char *a3)
{
  FILE *v3; // rbp

  v3 = fopen(a3, "wb");
  fwrite(ptr, a2, 1u, v3);
  return fclose(v3);
}

//----- (00000000004019C0) ----------------------------------------------------
char *__fastcall sub_4019C0(__int64 a1, int a2, int a3, int a4, int a5)
{
  char *result; // rax
  int v9; // ecx
  int v10; // r14d
  const char *v11; // rax
  int v12; // ebx
  int v13; // r13d
  int v14; // ebx
  int v15; // r15d
  int v16; // eax
  int v17; // r14d
  int v18; // r13d
  int v19; // r12d
  int v20; // edx
  char v21; // r8
  int v22; // eax
  char *v23; // rax
  int v24; // [rsp+4h] [rbp-20DCh]
  int v26; // [rsp+Ch] [rbp-20D4h]
  const char *v27; // [rsp+10h] [rbp-20D0h]
  unsigned int v29; // [rsp+1Ch] [rbp-20C4h]
  __int64 v30; // [rsp+20h] [rbp-20C0h]
  char *dest; // [rsp+28h] [rbp-20B8h]
  int v32; // [rsp+3Ch] [rbp-20A4h]
  __int64 v33; // [rsp+40h] [rbp-20A0h]
  int v34; // [rsp+48h] [rbp-2098h]
  int v35; // [rsp+4Ch] [rbp-2094h]
  int v36; // [rsp+50h] [rbp-2090h]
  char v37; // [rsp+57h] [rbp-2089h]
  int v39; // [rsp+60h] [rbp-2080h]
  int v40; // [rsp+68h] [rbp-2078h]
  int v41; // [rsp+68h] [rbp-2078h]
  int v42; // [rsp+6Ch] [rbp-2074h]
  char s[64]; // [rsp+70h] [rbp-2070h] BYREF
  char src[8240]; // [rsp+B0h] [rbp-2030h] BYREF

  result = (char *)malloc(0x13A600u);
  dest = result;
  *result = 0;
  if ( a5 > 0 )
  {
    v9 = a3;
    v10 = a4;
    v26 = 4 * a3;
    v11 = "RGB";
    v39 = 0;
    if ( a4 )
      v11 = "RGBA";
    v12 = 0;
    v34 = 0;
    v27 = v11;
    v32 = 0;
    v29 = 0;
    v24 = v9 - 1;
    while ( 1 )
    {
      if ( (v12 & 3) != 0 )
        v12 += 2;
      v13 = v26 + v12;
      strcat(dest, src);
      printf(src);
      if ( a3 > 0 )
      {
        v33 = 0;
        v30 = v12 + a1;
        while ( 1 )
        {
          src[0] = 0;
          v36 = 0;
          if ( a2 <= 0 )
          {
            v42 = 0;
            v14 = 0;
            v15 = 0;
            v35 = 0;
          }
          else
          {
            v14 = 0;
            v15 = 0;
            v35 = 0;
            v42 = 0;
            v16 = v10;
            v17 = v13;
            v18 = v16;
            while ( 1 )
            {
              v19 = v17 + 1;
              v20 = *(unsigned __int8 *)(a1 + v17);
              if ( (*(_BYTE *)(a1 + v17) & 0x7F) == 0 )
                break;
              if ( (v20 & 0x80u) != 0 )
              {
                ++v39;
                v40 = *(_BYTE *)(a1 + v17) & 0x7F;
                ++v14;
                sprintf(s, "#%02X, ", v20);
                strcat(src, s);
                v42 += v40;
                if ( v18 )
                  v19 = v17 + 2;
                v15 += v40;
                v17 = v19 + 2;
                if ( v15 >= a2 )
                {
LABEL_19:
                  v22 = v18;
                  v13 = v17;
                  v10 = v22;
                  goto LABEL_21;
                }
              }
              else
              {
                v36 += v20;
                ++v17;
                v34 += v20;
                v37 = v20;
                v41 = v20;
                ++v35;
                ++v32;
                sprintf(s, "#%02X, ", v20);
                strcat(src, s);
                v21 = v37;
                v15 += v41;
                do
                {
                  v17 = v17 - ((v18 == 0) - 1) + 2;
                  --v21;
                }
                while ( v21 );
                if ( v15 >= a2 )
                  goto LABEL_19;
              }
            }
            v10 = v18;
            v13 = v19;
            sprintf(s, "counter 0 error at line:%d pix:%d %s, ", v33, v15, v27);
            strcat(src, s);
          }
LABEL_21:
          sprintf(s, "= %d pixel\n", v15);
          strcat(src, s);
          sprintf(
            s,
            "%02hhX,%02hhX - (%02hhX,%02hhX) - (%03X,%03X) {%04X}{%04X}{%04X} ",
            *(unsigned __int8 *)(v30 + 4 * v33 + 3),
            *(unsigned __int8 *)(v30 + 4 * v33 + 2),
            v32,
            v34,
            v39,
            v35,
            v14,
            v36,
            v42);
          v23 = stpcpy(&dest[strlen(dest)], s);
          strcpy(v23, src);
          if ( v24 == v33 )
            break;
          ++v33;
        }
      }
      ++v29;
      *(_WORD *)&dest[strlen(dest)] = 10;
      result = (char *)v29;
      if ( a5 == v29 )
        break;
      v12 = v13 - (((v13 & 1) == 0) - 1);
    }
  }
  return result;
}

//----- (0000000000401E40) ----------------------------------------------------
int __fastcall sub_401E40(const char *a1, int a2, int a3, int a4, __int64 a5)
{
  __int64 v8; // r15
  int v9; // r12d
  _QWORD *v10; // rax
  void *v11; // r10
  void **v12; // r13
  __int64 v13; // r14
  void *v14; // r12
  _QWORD *v15; // rbx
  size_t rowbytes; // rax
  int v17; // edx
  _QWORD *v18; // rcx
  __int64 v19; // rax
  int v20; // edi
  int v21; // r8d
  void *v22; // rdi
  void *ptra; // [rsp+0h] [rbp-58h]
  _QWORD *ptr; // [rsp+0h] [rbp-58h]
  FILE *stream; // [rsp+8h] [rbp-50h]
  void *v27; // [rsp+10h] [rbp-48h]
  int v28; // [rsp+10h] [rbp-48h]
  __int64 v29; // [rsp+18h] [rbp-40h]

  stream = fopen(a1, "wb");
  v8 = png_create_write_struct("1.6.36", 0, 0, 0);
  ptra = (void *)png_create_info_struct(v8);
  png_init_io(v8, stream);
  v9 = 4 - (a4 == 0);
  v27 = ptra;
  png_set_IHDR(v8, ptra, (unsigned int)a2, (unsigned int)a3, 8, a4 == 0 ? 2 : 6, 0, 0, 0);
  v10 = malloc(8LL * a3);
  v11 = ptra;
  ptr = v10;
  if ( a3 <= 0 )
  {
    png_write_info(v8, v27);
    png_write_image(v8, ptr);
    png_write_end(v8, 0);
  }
  else
  {
    v12 = (void **)v10;
    v28 = v9;
    v29 = a5;
    v13 = (__int64)&v10[(unsigned int)(a3 - 1) + 1];
    v14 = v11;
    v15 = v10;
    do
    {
      ++v15;
      rowbytes = png_get_rowbytes(v8, v14);
      *(v15 - 1) = malloc(rowbytes);
    }
    while ( v15 != (_QWORD *)v13 );
    v17 = 0;
    v18 = ptr;
    do
    {
      v19 = 0;
      v20 = 0;
      if ( a2 > 0 )
      {
        do
        {
          while ( 1 )
          {
            *(_BYTE *)(*v18 + v19) = *(_BYTE *)(v29 + v17);
            *(_BYTE *)(*v18 + v19 + 1) = *(_BYTE *)(v29 + v17 + 1);
            v21 = v17 + 3;
            *(_BYTE *)(*v18 + v19 + 2) = *(_BYTE *)(v29 + v17 + 2);
            if ( v28 == 4 )
              break;
            ++v20;
            v17 += 3;
            v19 += v28;
            if ( a2 == v20 )
              goto LABEL_10;
          }
          ++v20;
          v17 += 4;
          *(_BYTE *)(*v18 + v19 + 3) = *(_BYTE *)(v29 + v21);
          v19 += 4;
        }
        while ( a2 != v20 );
      }
LABEL_10:
      ++v18;
    }
    while ( v18 != (_QWORD *)v13 );
    png_write_info(v8, v14);
    png_write_image(v8, ptr);
    png_write_end(v8, 0);
    do
    {
      v22 = *v12++;
      free(v22);
    }
    while ( v12 != (void **)v13 );
  }
  free(ptr);
  return fclose(stream);
}
// 401030: using guessed type __int64 __fastcall png_write_info(_QWORD, _QWORD);
// 4010B0: using guessed type __int64 __fastcall png_write_image(_QWORD, _QWORD);
// 401100: using guessed type __int64 __fastcall png_get_rowbytes(_QWORD, _QWORD);
// 401120: using guessed type __int64 __fastcall png_write_end(_QWORD, _QWORD);
// 401140: using guessed type __int64 __fastcall png_create_info_struct(_QWORD);
// 401170: using guessed type __int64 __fastcall png_init_io(_QWORD, _QWORD);
// 401190: using guessed type __int64 __fastcall png_create_write_struct(_QWORD, _QWORD, _QWORD, _QWORD);
// 4011D0: using guessed type __int64 __fastcall png_set_IHDR(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000402070) ----------------------------------------------------
char *__fastcall sub_402070(int a1, int a2)
{
  __int64 v2; // r14
  int v3; // r12d
  int v4; // r15d
  const char *v5; // rdx
  char v7[1080]; // [rsp+0h] [rbp-438h] BYREF

  if ( a2 <= 0 )
  {
    v3 = 0;
  }
  else
  {
    v2 = 0;
    v3 = 0;
    while ( 1 )
    {
      v4 = *((_DWORD *)ptr + 5 * (unsigned __int8)byte_538D5A + v2 + 1);
      v5 = "#%02X, " + 5;
      if ( (v2 & 7) == 0 )
        v5 = "\n";
      if ( a1 )
        sprintf(v7, "%s%2d.=%08X", v5, v2, v4);
      else
        sprintf(v7, "%s%2d.=%5d byte", v5, v2, v4);
      v3 += v4;
      strncat(qword_538C40, v7, 0x8000u);
      if ( a2 - 1 == v2 )
        break;
      ++v2;
    }
  }
  if ( a1 )
    sprintf(v7, "\nsumma=0x%X byte\n", v3);
  else
    sprintf(v7, "\nsumma=%d byte\n", v3);
  return strncat(qword_538C40, v7, 0x8000u);
}
// 538D5A: using guessed type char byte_538D5A;

//----- (00000000004021A0) ----------------------------------------------------
__int64 __fastcall sub_4021A0(int a1)
{
  if ( *(char *)ptr > a1 )
    return *((unsigned int *)ptr + 5 * *((char *)ptr + 2) + a1 + 1);
  puts("Too big index!");
  return 0;
}

//----- (00000000004021F0) ----------------------------------------------------
int __fastcall sub_4021F0(char *a1, const char *a2)
{
  int result; // eax
  int v3; // r14d
  int v4; // r13d
  int v5; // ebx
  unsigned __int16 *v6; // r12
  int v7; // eax
  int v8; // ecx
  int v9; // [rsp+Ch] [rbp-CCh]
  int v10; // [rsp+1Ch] [rbp-BCh] BYREF
  char dest[184]; // [rsp+20h] [rbp-B8h] BYREF

  result = (unsigned int)strncpy(dest, a2, 0x14u);
  v3 = *((unsigned __int16 *)a1 + 3);
  v4 = *((unsigned __int16 *)a1 + 4);
  if ( (unsigned __int16)v3 > 0x400u || *((unsigned __int16 *)a1 + 4) > 0x640u )
    return printf("Wrong image size! (%dx%d)\n", *((unsigned __int16 *)a1 + 3), *((unsigned __int16 *)a1 + 4));
  if ( a1[14] )
  {
    v5 = 0;
    v6 = (unsigned __int16 *)((char *)ptr + *(unsigned int *)a1);
    do
    {
      sub_4021A0(v5 + (unsigned __int8)a1[4]);
      *(_WORD *)stpcpy(filename, ::dest) = 47;
      sprintf(dest, "chr_%s_%c.png", a2, (unsigned int)(v5 + 48));
      strcat(filename, dest);
      if ( a1[15] >= 0 )
      {
        v7 = sub_4016B0(v6, (__int64)&unk_405140, &v10, v3, v4, 0, 0);
        v8 = 0;
      }
      else
      {
        v7 = sub_4016B0(v6, (__int64)&unk_405140, &v10, v3, v4, 1, 0);
        v8 = 1;
      }
      v9 = v7;
      ++v5;
      sub_401E40(filename, v3, v4, v8, (__int64)&unk_405140);
      v6 = (unsigned __int16 *)((char *)v6 + v9);
      result = (unsigned __int8)a1[14];
    }
    while ( result > v5 );
  }
  return result;
}

//----- (0000000000402370) ----------------------------------------------------
int __fastcall sub_402370(unsigned int *a1, const char *a2, __int64 a3, int a4)
{
  int v4; // r14d
  int v5; // r13d
  char *v6; // r12
  char *v7; // rax
  char *v9; // rax
  int v10; // [rsp-10h] [rbp-48h]
  int v11[11]; // [rsp+Ch] [rbp-2Ch] BYREF

  v4 = *((unsigned __int16 *)a1 + 3);
  v5 = *((unsigned __int16 *)a1 + 4);
  v6 = (char *)ptr + *a1;
  if ( (unsigned __int16)v4 > 0x400u || *((unsigned __int16 *)a1 + 4) > 0x640u )
    return printf("Wrong image size! (%dx%d)\n", *((unsigned __int16 *)a1 + 3), *((unsigned __int16 *)a1 + 4));
  if ( a4 )
  {
    v9 = stpcpy(filename, dest);
    *v9 = 47;
    strcpy(stpcpy(v9 + 1, a2), ".bin");
    v11[0] = sub_4021A0(*((unsigned __int8 *)a1 + 4));
    sub_401980(v6, v11[0], filename);
  }
  v7 = stpcpy(filename, dest);
  *v7 = 47;
  strcpy(stpcpy(v7 + 1, a2), ".png");
  if ( *((char *)a1 + 15) >= 0 )
  {
    sub_4016B0((unsigned __int16 *)v6, (__int64)&unk_405140, v11, v4, v5, 0, 0);
    sub_401E40(filename, v4, v5, 0, (__int64)&unk_405140);
    return v10;
  }
  else
  {
    if ( *((_BYTE *)a1 + 17) == 6 )
      sub_4016B0((unsigned __int16 *)v6, (__int64)&unk_405140, v11, v4, v5, 1, 0);
    else
      sub_4015D0((__int64)v6, (__int64)&unk_405140, (__int64)v11, v4, v5);
    return sub_401E40(filename, v4, v5, 1, (__int64)&unk_405140);
  }
}
// 402469: variable 'v10' is possibly undefined

//----- (0000000000402520) ----------------------------------------------------
char *__fastcall sub_402520(_DWORD *a1, int a2)
{
  unsigned __int8 v2; // r14
  int v3; // edx
  const char *v4; // rcx
  const char *v5; // r8
  char v7[128]; // [rsp+0h] [rbp-4B8h] BYREF
  char s[1080]; // [rsp+80h] [rbp-438h] BYREF

  v2 = *((_BYTE *)a1 + 1);
  printf("Block %2d.\n", a2);
  sprintf(s, "Block %2d.\n", a2);
  strncat(qword_538C40, s, 0x8000u);
  v3 = *((unsigned __int8 *)a1 + 15);
  v7[0] = 0;
  switch ( v3 & 0x7F )
  {
    case 1:
      strcpy(v7, "prev");
      sub_402370(a1, v7, v2, 0);
      v3 = *((unsigned __int8 *)a1 + 15);
      v4 = "Preview image";
      break;
    case 2:
      sprintf(v7, "background%d", a2);
      sub_402370(a1, v7, v2, 0);
      v3 = *((unsigned __int8 *)a1 + 15);
      v4 = "Background image";
      break;
    case 3:
      strcpy(v7, "arm_hour");
      sub_402370(a1, v7, v2, 0);
      v3 = *((unsigned __int8 *)a1 + 15);
      v4 = "Arm hour";
      break;
    case 4:
      strcpy(v7, "arm_minute");
      sub_402370(a1, v7, v2, 0);
      v3 = *((unsigned __int8 *)a1 + 15);
      v4 = "Arm minute";
      break;
    case 5:
      strcpy(v7, "arm_second");
      sub_402370(a1, v7, v2, 0);
      v3 = *((unsigned __int8 *)a1 + 15);
      v4 = "Arm second";
      break;
    case 6:
      v4 = "Year";
      break;
    case 7:
      strcpy(v7, "Month");
      sub_4021F0((char *)a1, v7);
      v3 = *((unsigned __int8 *)a1 + 15);
      v4 = "Month";
      break;
    case 8:
      v4 = "Day";
      break;
    case 9:
      strcpy(v7, "hours");
      sub_4021F0((char *)a1, v7);
      v3 = *((unsigned __int8 *)a1 + 15);
      v4 = "Hours";
      break;
    case 0xA:
      strcpy(v7, "minutes");
      sub_4021F0((char *)a1, v7);
      v3 = *((unsigned __int8 *)a1 + 15);
      v4 = "Minutes";
      break;
    case 0xB:
      strcpy(v7, "seconds");
      sub_4021F0((char *)a1, v7);
      v3 = *((unsigned __int8 *)a1 + 15);
      v4 = "Seconds";
      break;
    case 0xC:
      v4 = "AM/PM";
      break;
    case 0xD:
      v4 = "Day of week";
      break;
    case 0xE:
      strcpy(v7, "steps");
      sub_4021F0((char *)a1, v7);
      v3 = *((unsigned __int8 *)a1 + 15);
      v4 = "Steps";
      break;
    case 0xF:
      v4 = "Pulse";
      break;
    case 0x10:
      v4 = "Calory";
      break;
    case 0x11:
      v4 = "Distance";
      break;
    case 0x12:
      v4 = "Battery";
      break;
    case 0x13:
    case 0x14:
    case 0x15:
    case 0x19:
    case 0x1A:
    case 0x1B:
    case 0x1C:
    case 0x1D:
    case 0x1E:
    case 0x1F:
      v4 = "Unknown ???";
      break;
    case 0x16:
      strcpy(v7, "bigyo");
      sub_402370(a1, v7, v2, 0);
      v3 = *((unsigned __int8 *)a1 + 15);
      v4 = "axle pawl";
      break;
    case 0x17:
      v4 = "Animation";
      strcpy(v7, "animpart.png");
      break;
    case 0x18:
      strcpy(v7, "battery");
      sub_4021F0((char *)a1, v7);
      v3 = *((unsigned __int8 *)a1 + 15);
      v4 = "Battery strip";
      break;
    case 0x27:
      strcpy(v7, "hour Hi");
      sub_4021F0((char *)a1, v7);
      v3 = *((unsigned __int8 *)a1 + 15);
      v4 = "HoursHi";
      break;
    case 0x28:
      strcpy(v7, "hour Lo");
      sub_4021F0((char *)a1, v7);
      v3 = *((unsigned __int8 *)a1 + 15);
      v4 = "HoursLo";
      break;
    case 0x29:
      strcpy(v7, "minute Hi");
      sub_4021F0((char *)a1, v7);
      v3 = *((unsigned __int8 *)a1 + 15);
      v4 = "MinuteHi";
      break;
    case 0x2A:
      strcpy(v7, "minute Lo");
      sub_4021F0((char *)a1, v7);
      v3 = *((unsigned __int8 *)a1 + 15);
      v4 = "MinuteLo";
      break;
    default:
      v4 = "Unknown ?????";
      break;
  }
  v5 = "RGBA";
  if ( (v3 & 0x80u) == 0 )
    v5 = "RGB";
  sprintf(s, "    0x%02X type: %s %4s (%s)\n", v3, v4, v5, v7);
  printf("%s", s);
  strncat(qword_538C40, s, 0x8000u);
  sprintf(s, "    0x%08X    (%7u) picture address\n", *a1, *a1);
  printf("%s", s);
  strncat(qword_538C40, s, 0x8000u);
  sprintf(
    s,
    "    0x%02X,0x%02X     (%3u,%3u) picidx,valami2\n",
    *((unsigned __int8 *)a1 + 4),
    *((unsigned __int8 *)a1 + 5),
    *((unsigned __int8 *)a1 + 4),
    *((unsigned __int8 *)a1 + 5));
  printf("%s", s);
  strncat(qword_538C40, s, 0x8000u);
  sprintf(
    s,
    "    0x%04X,0x%04X (%3u,%3u) sx,sy\n",
    *((unsigned __int16 *)a1 + 3),
    *((unsigned __int16 *)a1 + 4),
    *((unsigned __int16 *)a1 + 3),
    *((unsigned __int16 *)a1 + 4));
  printf("%s", s);
  strncat(qword_538C40, s, 0x8000u);
  sprintf(
    s,
    "    0x%04X,0x%04X (%3u,%3u) posX,posY\n",
    *((unsigned __int16 *)a1 + 5),
    *((unsigned __int16 *)a1 + 6),
    *((unsigned __int16 *)a1 + 5),
    *((unsigned __int16 *)a1 + 6));
  printf("%s", s);
  strncat(qword_538C40, s, 0x8000u);
  sprintf(
    s,
    "    0x%02X,0x%02X     (%3u,%3u) parts,blocktype\n",
    *((unsigned __int8 *)a1 + 14),
    *((unsigned __int8 *)a1 + 15),
    *((unsigned __int8 *)a1 + 14),
    *((unsigned __int8 *)a1 + 15));
  printf("%s", s);
  strncat(qword_538C40, s, 0x8000u);
  sprintf(
    s,
    "    0x%02X,0x%02X,0x%02X,0x%02X (%3u,%3u,%3u,%3u) align,compr,centX,centY\n",
    *((unsigned __int8 *)a1 + 16),
    *((unsigned __int8 *)a1 + 17),
    *((unsigned __int8 *)a1 + 18),
    *((unsigned __int8 *)a1 + 19),
    *((unsigned __int8 *)a1 + 16),
    *((unsigned __int8 *)a1 + 17),
    *((unsigned __int8 *)a1 + 18),
    *((unsigned __int8 *)a1 + 19));
  printf("%s", s);
  return strncat(qword_538C40, s, 0x8000u);
}

//----- (0000000000402CC0) ----------------------------------------------------
void sub_402CC0()
{
  int v0; // ebp
  char *v1; // rax
  int v2; // edx
  __int64 v3; // rbp
  int v4; // ebx
  _DWORD *v5; // rdi
  char *v6; // rax
  FILE *v7; // rax
  char *v8; // r12
  FILE *v9; // rbp
  size_t v10; // rax
  char s[1048]; // [rsp+40h] [rbp-418h] BYREF

  v0 = *(unsigned __int16 *)ptr;
  printf("----------- %s -----------\n", qword_538C20);
  v1 = (char *)malloc(0x8000u);
  qword_538C40 = v1;
  if ( v1 )
  {
    v2 = (unsigned __int8)byte_538D5A;
    *v1 = 0;
    sprintf(s, "Number of block = %d , (0x%04X)\n", v2, v2);
    printf("%s", s);
    strncat(qword_538C40, s, 0x8000u);
    sprintf(s, "Size of pltable = %d , (0x%04X)\n", v0, v0);
    printf("%s", s);
    strncat(qword_538C40, s, 0x8000u);
    sub_402070(0, v0);
    sub_402070(1, v0);
    if ( byte_538D5A )
    {
      v3 = 4;
      v4 = 0;
      do
      {
        ++v4;
        v5 = (char *)ptr + v3;
        v3 += 20;
        sub_402520(v5, v4);
      }
      while ( v4 < (unsigned __int8)byte_538D5A );
    }
    v6 = stpcpy(filename, dest);
    *(_WORD *)v6 = 47;
    strcpy(v6 + 1, "block_all.txt");
    v7 = fopen(filename, "wb");
    v8 = qword_538C40;
    v9 = v7;
    v10 = strlen(qword_538C40);
    fwrite(v8, v10, 1u, v9);
    fclose(v9);
    free(qword_538C40);
  }
  else
  {
    puts("stxt malloc error!");
  }
}
// 538D5A: using guessed type char byte_538D5A;

//----- (0000000000402ED0) ----------------------------------------------------
void __fastcall init(unsigned int a1, __int64 a2, __int64 a3)
{
  signed __int64 v4; // rbp
  __int64 i; // rbx

  init_proc();
  v4 = &off_404DF8 - off_404DF0;
  if ( v4 )
  {
    for ( i = 0; i != v4; ++i )
      ((void (__fastcall *)(_QWORD, __int64, __int64))off_404DF0[i])(a1, a2, a3);
  }
}
// 404DF0: using guessed type __int64 (__fastcall *off_404DF0[2])();
// 404DF8: using guessed type __int64 (__fastcall *off_404DF8)();

//----- (0000000000402F40) ----------------------------------------------------
void fini(void)
{
  ;
}

//----- (0000000000402F48) ----------------------------------------------------
void term_proc()
{
  ;
}

// nfuncs=81 queued=23 decompiled=23 lumina nreq=0 worse=0 better=0
// ALL OK, 23 function(s) have been successfully decompiled
